# project structure
# whatsapp_ai_automation/
# ├── pyproject.toml
# ├── config.json
# ├── main.py
# └── requirements.txt (generated by Poetry for reference)

# pyproject.toml
[tool.poetry]
name = "whatsapp-ai-automation"
version = "0.1.0"
description = "Automate WhatsApp messaging with AI chatbots using Playwright"
authors = ["Your Name <your.email@example.com>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.10"
playwright = "^1.48.0"
pyperclip = "^1.9.0"
python-dotenv = "^1.0.1"

[tool.poetry.group.dev.dependencies]
black = "^24.8.0"
flake8 = "^7.1.1"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

# config.json
{
  "ai_mappings": {
    "Grok Group": {
      "url": "https://grok.x.ai/",
      "tab_name": "Grok",
      "input_selector": "textarea[placeholder='Ask Grok anything...']",
      "response_selector": ".response-message:last-child"
    },
    "ChatGPT Group": {
      "url": "https://chat.openai.com/",
      "tab_name": "ChatGPT",
      "input_selector": "#prompt-textarea",
      "response_selector": ".message:last-child"
    },
    "Gemini Group": {
      "url": "https://gemini.google.com/",
      "tab_name": "Gemini",
      "input_selector": "input[placeholder='Type your question...']",
      "response_selector": ".response-container:last-child"
    },
    "Claude Group": {
      "url": "https://claude.ai/",
      "tab_name": "Claude",
      "input_selector": "textarea[placeholder='Talk to Claude...']",
      "response_selector": ".chat-message:last-child"
    },
    "Perplexity Group": {
      "url": "https://www.perplexity.ai/",
      "tab_name": "Perplexity",
      "input_selector": "textarea[placeholder='Ask anything...']",
      "response_selector": ".answer-text:last-child"
    }
  },
  "whatsapp_url": "https://web.whatsapp.com/"
}

# main.py
import json
import logging
import time
from playwright.sync_api import sync_playwright, TimeoutError as PlaywrightTimeoutError
import pyperclip

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("automation.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class WhatsAppAIAutomation:
    def __init__(self, config_path="config.json"):
        self.config = self.load_config(config_path)
        self.browser = None
        self.context = None
        self.tabs = {}
        self.whatsapp_page = None
        self.last_message = None

    def load_config(self, config_path):
        """Load configuration from JSON file."""
        try:
            with open(config_path, "r") as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Failed to load config: {e}")
            raise

    def setup_browser(self):
        """Initialize browser and open tabs for WhatsApp and AI platforms."""
        playwright = sync_playwright().start()
        self.browser = playwright.chromium.launch(headless=False)  # Headless=False for visibility
        self.context = self.browser.new_context()

        # Open WhatsApp tab
        self.whatsapp_page = self.context.new_page()
        self.whatsapp_page.goto(self.config["whatsapp_url"])
        self.tabs["WhatsApp"] = self.whatsapp_page
        logger.info("Opened WhatsApp Web tab")

        # Open AI platform tabs
        for group, ai_config in self.config["ai_mappings"].items():
            page = self.context.new_page()
            page.goto(ai_config["url"])
            self.tabs[ai_config["tab_name"]] = page
            logger.info(f"Opened tab for {ai_config['tab_name']}")

        # Wait for user to log in (manual login)
        logger.info("Please log in to all platforms. Waiting for 60 seconds...")
        time.sleep(60)  # Adjust as needed for manual login

    def truncate_message(self, message, max_length=350):
        """Truncate message to max_length characters."""
        if len(message) > max_length:
            return message[:max_length-3] + "..."
        return message

    def get_whatsapp_messages(self):
        """Check for new messages in WhatsApp."""
        try:
            # Selector for the latest message in the chat (update as needed)
            message_elements = self.whatsapp_page.query_selector_all(".message-in .message-text")
            if not message_elements:
                return None, None

            latest_message = message_elements[-1].inner_text()
            # Get the group name (update selector based on WhatsApp Web's DOM)
            group_element = self.whatsapp_page.query_selector(".chat-title")
            group_name = group_element.inner_text() if group_element else "Unknown"

            if latest_message != self.last_message:
                self.last_message = latest_message
                return group_name, latest_message
            return None, None
        except Exception as e:
            logger.error(f"Error fetching WhatsApp messages: {e}")
            return None, None

    def send_to_ai(self, group_name, message):
        """Send message to the corresponding AI platform and get response."""
        ai_config = self.config["ai_mappings"].get(group_name)
        if not ai_config:
            logger.warning(f"No AI mapping found for group: {group_name}")
            return None

        tab_name = ai_config["tab_name"]
        page = self.tabs.get(tab_name)
        if not page:
            logger.error(f"Tab {tab_name} not found")
            return None

        try:
            # Truncate message
            message = self.truncate_message(message)

            # Input message (replace with actual selector)
            input_field = page.query_selector(ai_config["input_selector"])
            if not input_field:
                logger.error(f"Input field not found for {tab_name}")
                return None

            input_field.fill(message)
            input_field.press("Enter")
            logger.info(f"Sent message to {tab_name}: {message}")

            # Wait for response (adjust timeout and selector)
            page.wait_for_selector(ai_config["response_selector"], timeout=30000)
            response_element = page.query_selector(ai_config["response_selector"])
            response = response_element.inner_text() if response_element else "No response"
            logger.info(f"Received response from {tab_name}: {response[:50]}...")
            return response
        except PlaywrightTimeoutError:
            logger.error(f"Timeout waiting for response from {tab_name}")
            return None
        except Exception as e:
            logger.error(f"Error interacting with {tab_name}: {e}")
            return None

    def send_to_whatsapp(self, message):
        """Send response back to WhatsApp."""
        try:
            # Focus on WhatsApp tab
            self.whatsapp_page.bring_to_front()

            # Copy message to clipboard (avoids issues with special characters)
            pyperclip.copy(message)

            # Paste into WhatsApp input field (update selector)
            input_field = self.whatsapp_page.query_selector("div[title='Type a message']")
            if not input_field:
                logger.error("WhatsApp input field not found")
                return

            input_field.click()
            self.whatsapp_page.keyboard.press("Control+V")
            self.whatsapp_page.keyboard.press("Enter")
            logger.info(f"Sent response to WhatsApp: {message[:50]}...")
        except Exception as e:
            logger.error(f"Error sending to WhatsApp: {e}")

    def run(self):
        """Main loop to monitor WhatsApp and process messages."""
        try:
            self.setup_browser()
            logger.info("Starting message monitoring loop")
            while True:
                group_name, message = self.get_whatsapp_messages()
                if group_name and message:
                    logger.info(f"New message in {group_name}: {message[:50]}...")
                    response = self.send_to_ai(group_name, message)
                    if response:
                        self.send_to_whatsapp(response)
                time.sleep(5)  # Poll every 5 seconds
        except KeyboardInterrupt:
            logger.info("Shutting down...")
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
        finally:
            self.cleanup()

    def cleanup(self):
        """Close browser and clean up."""
        if self.context:
            self.context.close()
        if self.browser:
            self.browser.close()
        logger.info("Browser closed")

if __name__ == "__main__":
    automation = WhatsAppAIAutomation()
    automation.run()

# README.md (for reference, not executed)
# WhatsApp AI Automation

A Python project to automate interactions between WhatsApp Web and AI chatbots using Playwright.

## Setup

1. **Install Poetry**:
   ```bash
   curl -sSL https://install.python-poetry.org | python3 -
   ```

2. **Clone the project**:
   ```bash
   git clone <your-repo-url>
   cd whatsapp-ai-automation
   ```

3. **Install dependencies**:
   ```bash
   poetry install
   ```

4. **Install Playwright browsers**:
   ```bash
   poetry run playwright install
   ```

5. **Configure**:
   - Edit `config.json` with correct URLs and selectors for AI platforms.
   - Ensure group names in WhatsApp match the keys in `ai_mappings`.

6. **Run the project**:
   ```bash
   poetry run python main.py
   ```

## Notes
- Log in manually to each platform when prompted.
- Update selectors in `config.json` based on actual DOM elements (use browser DevTools).
- The project polls WhatsApp every 5 seconds; adjust as needed.
- Logs are saved to `automation.log`.

## Troubleshooting
- If a tab fails to load, check the URL and network connection.
- If interactions fail, verify selectors using browser DevTools.
- For WhatsApp, ensure the chat is active and focused.
